# [리팩토링 제목] - [간단한 설명]

> **Version**: 1.0.0
> **Last Updated**: YYYY-MM-DD
> **Author**: {작성자}

---

## 📌 기술 키워드 (Technical Keywords)

| 카테고리 | 키워드 |
|---------|--------|
| **리팩토링 기법** | `Extract Method`, `Extract Class`, `Replace Conditional`, `Introduce Parameter Object` |
| **설계 원칙** | `SOLID`, `DRY`, `KISS`, `YAGNI`, `SoC` |
| **디자인 패턴** | `Strategy`, `Factory`, `Template Method`, `Builder`, `Decorator` |
| **코드 품질** | `Cyclomatic Complexity`, `Code Coverage`, `Technical Debt`, `Maintainability Index` |
| **도구** | `SonarQube`, `JaCoCo`, `IntelliJ Refactoring`, `Spotless` |

---

<!--
📝 작성 가이드:
- 제목: 리팩토링의 핵심을 한 줄로 (예: "JPA Dirty Checking 활용한 성능 최적화")
- 이 템플릿은 레거시 코드 개선, 기술 부채 해소, 아키텍처 개선 경험을 문서화할 때 사용
- 이력서/포트폴리오용이므로 Before/After 비교, 정량적 성과를 강조
- 코드 품질 향상, 유지보수성 개선 등을 어필
-->

> **작성일**: YYYY년 MM월
> **프로젝트**: [프로젝트명]
> **도메인**: [관련 도메인/기술 스택]
> **리팩토링 범위**: [파일 수, 코드 라인 수 등]

## 📋 목차

1. [리팩토링 배경](#1-리팩토링-배경)
2. [문제점 분석](#2-문제점-분석)
3. [리팩토링 목표](#3-리팩토링-목표)
4. [리팩토링 전략](#4-리팩토링-전략)
5. [주요 변경 사항](#5-주요-변경-사항)
6. [성과 및 개선 효과](#6-성과-및-개선-효과)
7. [교훈 및 Best Practices](#7-교훈-및-best-practices)

---

## 1. 리팩토링 배경

<!--
왜 리팩토링이 필요했는가?
- 기술 부채 누적
- 성능 문제
- 유지보수 어려움
-->

### 리팩토링 계기
- **문제 인식**: [언제, 어떻게 문제를 인식했는가]
- **비즈니스 임팩트**: [문제가 미치는 영향]
- **의사결정**: [왜 지금 리팩토링을 해야 했는가]

### 대상 코드 현황
- **작성 시기**: [예: 6개월 전, 초기 MVP 시절]
- **작성자**: [예: 전 담당자, 레거시 코드]
- **규모**: [파일 수, 코드 라인, 복잡도 등]
- **변경 이력**: [얼마나 자주 수정되었는가]

### 기술 부채 분석
| 항목 | 상태 | 심각도 |
|------|------|--------|
| **코드 복잡도** | [예: Cyclomatic Complexity 15+] | High |
| **중복 코드** | [예: 30% 중복] | Medium |
| **테스트 커버리지** | [예: 20%] | High |
| **성능** | [예: 평균 2초 응답] | Critical |

---

## 2. 문제점 분석

<!--
구체적으로 어떤 문제가 있었는가?
- 코드 스멜
- 안티 패턴
- 성능 이슈
-->

### 주요 문제점

**문제 1**: [문제 제목]
- **증상**: [어떤 현상이 발생했는가]
- **원인**: [왜 이런 코드가 되었는가]
- **영향**: [어떤 부작용이 있었는가]

**문제 2**: [문제 제목]
- **증상**: [어떤 현상이 발생했는가]
- **원인**: [왜 이런 코드가 되었는가]
- **영향**: [어떤 부작용이 있었는가]

**문제 3**: [문제 제목]
- **증상**: [어떤 현상이 발생했는가]
- **원인**: [왜 이런 코드가 되었는가]
- **영향**: [어떤 부작용이 있었는가]

### 코드 스멜 (Code Smell)

**스멜 1**: [스멜명 - 예: God Object]
```java
// ❌ BAD: 문제가 있는 코드
public class MassiveService {
    // 500줄 이상의 거대한 클래스
    // 너무 많은 책임을 가짐
}
```

**스멜 2**: [스멜명 - 예: Shotgun Surgery]
```java
// ❌ BAD: 한 가지 변경이 여러 곳 수정 필요
public class Service1 {
    // 중복된 로직
}

public class Service2 {
    // 동일한 로직 반복
}
```

### 성능 문제

**이슈 1**: [성능 이슈 제목]
- **측정 결과**: [예: 평균 2000ms, P95 5000ms]
- **병목 지점**: [어디가 느린가]
- **원인**: [왜 느린가]

**이슈 2**: [성능 이슈 제목]
- **측정 결과**: [예: 메모리 사용량 500MB]
- **병목 지점**: [어디가 문제인가]
- **원인**: [왜 문제인가]

---

## 3. 리팩토링 목표

<!--
무엇을 달성하려고 하는가?
- 정량적 목표
- 정성적 목표
-->

### 정량적 목표

| 지표 | Before | Target | 우선순위 |
|------|--------|--------|----------|
| **응답 시간** | [예: 2000ms] | < 200ms | Critical |
| **코드 복잡도** | [예: CC 15] | < 10 | High |
| **중복률** | [예: 30%] | < 5% | High |
| **테스트 커버리지** | [예: 20%] | > 80% | Medium |
| **코드 라인 수** | [예: 1000줄] | < 500줄 | Medium |

### 정성적 목표
- ✅ **가독성 향상**: [예: 신규 개발자도 쉽게 이해 가능]
- ✅ **유지보수성 개선**: [예: 변경 시 영향 범위 최소화]
- ✅ **확장성 확보**: [예: 새 기능 추가 용이]
- ✅ **설계 원칙 준수**: [예: SOLID 원칙 적용]

---

## 4. 리팩토링 전략

<!--
어떻게 리팩토링할 것인가?
- 단계별 계획
- 위험 관리
- 테스트 전략
-->

### 리팩토링 접근법

**선택한 방법**: [예: Strangler Fig Pattern, Big Bang, Incremental]

**이유**:
- [왜 이 방법을 선택했는가]
- [다른 방법의 문제점은 무엇인가]

### 단계별 계획

**Phase 1**: [단계 제목 - 예: 테스트 코드 작성]
- **기간**: [예: 1주]
- **목표**: [무엇을 달성할 것인가]
- **작업**: [구체적인 작업 내용]

**Phase 2**: [단계 제목 - 예: 코드 분리]
- **기간**: [예: 2주]
- **목표**: [무엇을 달성할 것인가]
- **작업**: [구체적인 작업 내용]

**Phase 3**: [단계 제목 - 예: 성능 최적화]
- **기간**: [예: 1주]
- **목표**: [무엇을 달성할 것인가]
- **작업**: [구체적인 작업 내용]

### 위험 관리

| 위험 | 발생 가능성 | 영향도 | 대응 방안 |
|------|------------|--------|-----------|
| **기능 손상** | Medium | High | [대응 방안] |
| **성능 저하** | Low | Medium | [대응 방안] |
| **일정 지연** | High | Medium | [대응 방안] |

### 테스트 전략

**기존 동작 보장**:
```java
// ✅ STEP 1: 기존 로직에 대한 회귀 테스트 작성
@Test
void testExistingBehavior() {
    // Given

    // When

    // Then - 기존 동작과 동일한지 검증
}
```

**리팩토링 후 검증**:
```java
// ✅ STEP 2: 리팩토링 후에도 동일한 결과
@Test
void testRefactoredBehavior() {
    // Given

    // When - 리팩토링된 코드 실행

    // Then - 기존 테스트와 동일한 결과
}
```

---

## 5. 주요 변경 사항

<!--
Before/After 코드 비교
- 구조적 변경
- 패턴 적용
- 최적화 기법
-->

### 변경 사항 1: [변경 제목]

**Before** (문제 코드):
```java
// ❌ BAD: 기존 코드의 문제점
public class LegacyService {

    public void massiveMethod() {
        // 200줄 이상의 거대한 메서드
        // 여러 책임을 동시에 수행
        // 테스트 불가능
    }
}
```

**After** (개선 코드):
```java
// ✅ GOOD: 개선된 코드
public class ImprovedService {

    private final ValidationService validationService;
    private final ProcessingService processingService;
    private final NotificationService notificationService;

    public void processRequest(Request request) {
        // 1. 검증 (Single Responsibility)
        validationService.validate(request);

        // 2. 처리
        Result result = processingService.process(request);

        // 3. 알림
        notificationService.notify(result);
    }
}
```

**개선 포인트**:
- ✅ **단일 책임 원칙**: 각 서비스가 하나의 책임만
- ✅ **의존성 주입**: 테스트 가능한 구조
- ✅ **가독성 향상**: 메서드 이름만으로 흐름 파악 가능

### 변경 사항 2: [변경 제목]

**Before**:
```java
// ❌ BAD: 안티 패턴
```

**After**:
```java
// ✅ GOOD: 개선된 패턴
```

**개선 포인트**:
- ✅ [포인트 1]
- ✅ [포인트 2]

### 적용한 리팩토링 기법

**기법 1**: [기법명 - 예: Extract Method]
- **적용 위치**: [어디에 적용했는가]
- **Before**: [이전 상태]
- **After**: [개선 상태]
- **효과**: [어떤 이점이 있었는가]

**기법 2**: [기법명 - 예: Replace Conditional with Polymorphism]
- **적용 위치**: [어디에 적용했는가]
- **Before**: [이전 상태]
- **After**: [개선 상태]
- **효과**: [어떤 이점이 있었는가]

### 적용한 디자인 패턴

**패턴 1**: [패턴명 - 예: Strategy Pattern]
- **문제**: [어떤 문제를 해결했는가]
- **적용**: [어떻게 적용했는가]
- **효과**: [어떤 이점이 있었는가]

---

## 6. 성과 및 개선 효과

<!--
리팩토링의 결과를 정량적/정성적으로 측정
- 성능 개선
- 코드 품질 향상
- 생산성 증가
-->

### 정량적 성과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| **응답 시간** | [예: 2000ms] | [예: 180ms] | **↓ 91%** |
| **코드 라인 수** | [예: 1000줄] | [예: 450줄] | **↓ 55%** |
| **코드 복잡도** | [예: CC 15] | [예: CC 5] | **↓ 67%** |
| **중복률** | [예: 30%] | [예: 3%] | **↓ 90%** |
| **테스트 커버리지** | [예: 20%] | [예: 85%] | **↑ 325%** |
| **메모리 사용량** | [예: 500MB] | [예: 150MB] | **↓ 70%** |

### 정성적 성과

**코드 품질 향상**:
- ✅ **가독성**: [예: 신규 개발자 온보딩 시간 50% 단축]
- ✅ **유지보수성**: [예: 버그 수정 시간 70% 감소]
- ✅ **확장성**: [예: 신규 기능 추가 시간 40% 단축]

**개발 생산성 향상**:
- ✅ **개발 속도**: [예: 유사 기능 개발 시간 30% 단축]
- ✅ **버그 감소**: [예: 프로덕션 버그 60% 감소]
- ✅ **코드 리뷰 시간**: [예: 평균 30분 → 10분]

**기술 부채 해소**:
- ✅ **SonarQube 등급**: [예: C → A]
- ✅ **기술 부채 비율**: [예: 30% → 5%]
- ✅ **보안 취약점**: [예: 15개 → 0개]

### Before/After 비교표

| 항목 | Before | After | 개선 |
|------|--------|-------|------|
| **설계 원칙** | ❌ 위반 다수 | ✅ SOLID 준수 | 설계 품질 향상 |
| **패턴 적용** | ❌ 안티 패턴 | ✅ GoF 패턴 적용 | 유지보수성 향상 |
| **테스트** | ❌ 테스트 불가능 | ✅ 100% 테스트 가능 | 안정성 향상 |

---

## 7. 교훈 및 Best Practices

<!--
이 리팩토링에서 배운 것
- 기술적 교훈
- 프로세스 개선
- 재사용 가능한 패턴
-->

### 핵심 교훈

**교훈 1**: [제목]
- **상황**: [어떤 상황이었는가]
- **문제**: [무엇이 문제였는가]
- **교훈**: [무엇을 배웠는가]
- **적용**: [다음에 어떻게 할 것인가]

**교훈 2**: [제목]
- **상황**: [어떤 상황이었는가]
- **문제**: [무엇이 문제였는가]
- **교훈**: [무엇을 배웠는가]
- **적용**: [다음에 어떻게 할 것인가]

### Best Practices

**Practice 1**: [제목]
- **원칙**: [어떤 원칙을 따랐는가]
- **이유**: [왜 이것이 중요한가]
- **예시**: [구체적인 적용 예시]

**Practice 2**: [제목]
- **원칙**: [어떤 원칙을 따랐는가]
- **이유**: [왜 이것이 중요한가]
- **예시**: [구체적인 적용 예시]

### 재사용 가능한 패턴

**패턴 1**: [패턴 제목]
```java
// ✅ 재사용 가능한 코드 패턴
public abstract class TemplateClass {

    public final void execute() {
        step1();
        step2();
        step3();
    }

    protected abstract void step1();
    protected abstract void step2();
    protected abstract void step3();
}
```

**적용 상황**: [어떤 경우에 사용하면 좋은가]

---

## 📌 리팩토링 체크리스트

<!--
다음 리팩토링 시 참고할 체크리스트
-->

### 리팩토링 전
- [ ] 기존 동작에 대한 테스트 코드 작성
- [ ] 성능 기준선(Baseline) 측정
- [ ] 영향 범위 분석 완료
- [ ] 위험 요소 식별 및 대응 방안 수립

### 리팩토링 중
- [ ] 작은 단위로 커밋 (각 단계마다)
- [ ] 테스트 계속 통과하는지 확인
- [ ] 코드 리뷰 진행
- [ ] 문서화 동시 진행

### 리팩토링 후
- [ ] 모든 테스트 통과 확인
- [ ] 성능 개선 검증
- [ ] 코드 품질 지표 확인 (SonarQube 등)
- [ ] 팀 공유 및 문서화

---

## 8. 테스트 검증 결과 (Test Verification)

### 8.1 회귀 테스트 결과
```
[기존 기능 테스트]
- 전체 테스트 케이스: N개
- 통과: N개
- 실패: 0개
- 커버리지: X% → Y%

[실행 결과]
Tests run: 150, Failures: 0, Errors: 0, Skipped: 0
BUILD SUCCESS
```

### 8.2 리팩토링 전 상태 (Before)
```
[코드 품질 지표]
- SonarQube 등급: C
- 코드 복잡도 (Cyclomatic): 15
- 중복률: 28%
- 테스트 커버리지: 25%
- 기술 부채: 8시간
- Bugs: 5개
- Code Smells: 42개
```

### 8.3 리팩토링 후 상태 (After)
```
[코드 품질 지표]
- SonarQube 등급: A ✅
- 코드 복잡도 (Cyclomatic): 5 ✅ (67% 감소)
- 중복률: 3% ✅ (89% 감소)
- 테스트 커버리지: 85% ✅ (240% 증가)
- 기술 부채: 30분 ✅ (94% 감소)
- Bugs: 0개 ✅
- Code Smells: 2개 ✅ (95% 감소)
```

### 8.4 테스트 커버리지
| 테스트 유형 | 테스트 케이스 | 결과 | 비고 |
|------------|--------------|------|------|
| 단위 테스트 | 기존 동작 검증 | ✅ Pass | 100% 호환 |
| 통합 테스트 | E2E 흐름 검증 | ✅ Pass | - |
| 회귀 테스트 | 기존 기능 정상 동작 | ✅ Pass | - |
| 성능 테스트 | 응답 시간 비교 | ✅ Pass | 10% 개선 |

### 8.5 검증 체크리스트
- [ ] 모든 기존 테스트 케이스 통과
- [ ] 리팩토링된 코드에 대한 신규 테스트 추가
- [ ] SonarQube 품질 게이트 통과
- [ ] 성능 회귀 없음 확인
- [ ] 코드 리뷰 완료

---

## 9. 면접 Q&A (Interview Questions)

### Q1. 이 리팩토링을 시작하게 된 계기는?
**A**: {리팩토링 필요성 인식 배경 설명}

**💡 포인트**:
- 기술 부채 누적으로 인한 개발 생산성 저하
- 버그 발생률 증가
- 코드 리뷰에서 반복적인 지적
- 신규 기능 개발 시간 증가

---

### Q2. 리팩토링 과정에서 어떻게 기존 동작을 보장했나요?
**A**: {테스트 전략과 안전한 리팩토링 방법 설명}

**💡 포인트**:
- 리팩토링 전 테스트 코드 작성 (Characterization Test)
- 작은 단위로 리팩토링 후 매번 테스트 실행
- 기능 변경 없이 구조만 개선 (Behavior Preserving)
- Git 커밋 단위를 작게 유지하여 롤백 가능

---

### Q3. 적용한 리팩토링 기법과 선택 이유는?
**A**: {적용 기법과 선택 근거 설명}

**💡 포인트**:
- Extract Method: 메서드가 너무 길어 가독성 저하
- Replace Conditional with Polymorphism: 복잡한 분기문 제거
- Introduce Parameter Object: 파라미터가 너무 많음
- Extract Class: 클래스가 너무 많은 책임을 가짐 (SRP 위반)

---

### Q4. SOLID 원칙을 어떻게 적용했나요?
**A**: {SOLID 원칙 적용 사례 설명}

**💡 포인트**:
- **SRP**: 각 클래스가 단일 책임만 갖도록 분리
- **OCP**: 확장에는 열려있고 수정에는 닫힌 설계
- **LSP**: 하위 타입이 상위 타입을 대체 가능하게
- **ISP**: 인터페이스 분리로 불필요한 의존성 제거
- **DIP**: 추상화에 의존하도록 변경

---

### Q5. 리팩토링 후 정량적으로 어떤 개선이 있었나요?
**A**: {정량적 성과 설명}

**💡 포인트**:
- 코드 라인 수: 1000줄 → 450줄 (55% 감소)
- 복잡도: CC 15 → CC 5 (67% 감소)
- 테스트 커버리지: 25% → 85%
- 버그 발생률: 월 5건 → 월 1건
- 코드 리뷰 시간: 30분 → 10분

---

### Q6. 리팩토링 시 주의해야 할 점은?
**A**: {리팩토링 주의사항 설명}

**💡 포인트**:
- 기능 변경과 리팩토링을 동시에 하지 않기
- 항상 테스트 코드로 보호된 상태에서 진행
- 작은 단위로 진행하고 자주 커밋
- 비즈니스 가치와 균형 맞추기 (무한 리팩토링 지양)
- 팀과 소통하며 진행 (코드 오너십)

---

## 🔗 관련 문서

<!--
관련 문서 링크
-->

- [리팩토링 대상 코드](../src/...)
- [개선된 코드](../src/...)
- [테스트 코드](../src/test/...)
- [관련 기술 문서](./OTHER_DOC.md)

---

## 📚 참고 자료

<!--
참고한 자료
-->

- [Refactoring: Improving the Design of Existing Code - Martin Fowler]
- [Clean Code - Robert C. Martin]
- [관련 블로그/아티클]

---

**작성자**: [이름]
**최종 수정일**: YYYY년 MM월
**버전**: 1.0.0
